// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client_logic_msg.proto

#ifndef PROTOBUF_client_5flogic_5fmsg_2eproto__INCLUDED
#define PROTOBUF_client_5flogic_5fmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "base_msg_struct.pb.h"
#include "error_code.pb.h"
// @@protoc_insertion_point(includes)

namespace net {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_5flogic_5fmsg_2eproto();
void protobuf_AssignDesc_client_5flogic_5fmsg_2eproto();
void protobuf_ShutdownFile_client_5flogic_5fmsg_2eproto();

class msg_heart_test;
class msg_login_req;
class msg_login_rep;
class msg_loginout_rep;
class msg_version_info_rep;
class msg_enter_game_rep;
class msg_player_data_rep;

// ===================================================================

class msg_heart_test : public ::google::protobuf::Message {
 public:
  msg_heart_test();
  virtual ~msg_heart_test();

  msg_heart_test(const msg_heart_test& from);

  inline msg_heart_test& operator=(const msg_heart_test& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_heart_test& default_instance();

  void Swap(msg_heart_test* other);

  // implements Message ----------------------------------------------

  msg_heart_test* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_heart_test& from);
  void MergeFrom(const msg_heart_test& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 svr_time = 1;
  inline bool has_svr_time() const;
  inline void clear_svr_time();
  static const int kSvrTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 svr_time() const;
  inline void set_svr_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:net.msg_heart_test)
 private:
  inline void set_has_svr_time();
  inline void clear_has_svr_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 svr_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_5flogic_5fmsg_2eproto();
  friend void protobuf_AssignDesc_client_5flogic_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_client_5flogic_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static msg_heart_test* default_instance_;
};
// -------------------------------------------------------------------

class msg_login_req : public ::google::protobuf::Message {
 public:
  msg_login_req();
  virtual ~msg_login_req();

  msg_login_req(const msg_login_req& from);

  inline msg_login_req& operator=(const msg_login_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_login_req& default_instance();

  void Swap(msg_login_req* other);

  // implements Message ----------------------------------------------

  msg_login_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_login_req& from);
  void MergeFrom(const msg_login_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes deviceid = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 3;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const void* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // optional bytes versionid = 4;
  inline bool has_versionid() const;
  inline void clear_versionid();
  static const int kVersionidFieldNumber = 4;
  inline const ::std::string& versionid() const;
  inline void set_versionid(const ::std::string& value);
  inline void set_versionid(const char* value);
  inline void set_versionid(const void* value, size_t size);
  inline ::std::string* mutable_versionid();
  inline ::std::string* release_versionid();
  inline void set_allocated_versionid(::std::string* versionid);

  // optional uint32 check_time = 5;
  inline bool has_check_time() const;
  inline void clear_check_time();
  static const int kCheckTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 check_time() const;
  inline void set_check_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:net.msg_login_req)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_versionid();
  inline void clear_has_versionid();
  inline void set_has_check_time();
  inline void clear_has_check_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* deviceid_;
  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 check_time_;
  ::std::string* versionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_client_5flogic_5fmsg_2eproto();
  friend void protobuf_AssignDesc_client_5flogic_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_client_5flogic_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static msg_login_req* default_instance_;
};
// -------------------------------------------------------------------

class msg_login_rep : public ::google::protobuf::Message {
 public:
  msg_login_rep();
  virtual ~msg_login_rep();

  msg_login_rep(const msg_login_rep& from);

  inline msg_login_rep& operator=(const msg_login_rep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_login_rep& default_instance();

  void Swap(msg_login_rep* other);

  // implements Message ----------------------------------------------

  msg_login_rep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_login_rep& from);
  void MergeFrom(const msg_login_rep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional uint32 server_time = 2;
  inline bool has_server_time() const;
  inline void clear_server_time();
  static const int kServerTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 server_time() const;
  inline void set_server_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:net.msg_login_rep)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_server_time();
  inline void clear_has_server_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 server_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_5flogic_5fmsg_2eproto();
  friend void protobuf_AssignDesc_client_5flogic_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_client_5flogic_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static msg_login_rep* default_instance_;
};
// -------------------------------------------------------------------

class msg_loginout_rep : public ::google::protobuf::Message {
 public:
  msg_loginout_rep();
  virtual ~msg_loginout_rep();

  msg_loginout_rep(const msg_loginout_rep& from);

  inline msg_loginout_rep& operator=(const msg_loginout_rep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_loginout_rep& default_instance();

  void Swap(msg_loginout_rep* other);

  // implements Message ----------------------------------------------

  msg_loginout_rep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_loginout_rep& from);
  void MergeFrom(const msg_loginout_rep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 reason = 1;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 1;
  inline ::google::protobuf::uint32 reason() const;
  inline void set_reason(::google::protobuf::uint32 value);

  // optional bytes deviceid = 2;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 2;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const void* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // @@protoc_insertion_point(class_scope:net.msg_loginout_rep)
 private:
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* deviceid_;
  ::google::protobuf::uint32 reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_client_5flogic_5fmsg_2eproto();
  friend void protobuf_AssignDesc_client_5flogic_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_client_5flogic_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static msg_loginout_rep* default_instance_;
};
// -------------------------------------------------------------------

class msg_version_info_rep : public ::google::protobuf::Message {
 public:
  msg_version_info_rep();
  virtual ~msg_version_info_rep();

  msg_version_info_rep(const msg_version_info_rep& from);

  inline msg_version_info_rep& operator=(const msg_version_info_rep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_version_info_rep& default_instance();

  void Swap(msg_version_info_rep* other);

  // implements Message ----------------------------------------------

  msg_version_info_rep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_version_info_rep& from);
  void MergeFrom(const msg_version_info_rep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const void* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:net.msg_version_info_rep)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_5flogic_5fmsg_2eproto();
  friend void protobuf_AssignDesc_client_5flogic_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_client_5flogic_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static msg_version_info_rep* default_instance_;
};
// -------------------------------------------------------------------

class msg_enter_game_rep : public ::google::protobuf::Message {
 public:
  msg_enter_game_rep();
  virtual ~msg_enter_game_rep();

  msg_enter_game_rep(const msg_enter_game_rep& from);

  inline msg_enter_game_rep& operator=(const msg_enter_game_rep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_enter_game_rep& default_instance();

  void Swap(msg_enter_game_rep* other);

  // implements Message ----------------------------------------------

  msg_enter_game_rep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_enter_game_rep& from);
  void MergeFrom(const msg_enter_game_rep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:net.msg_enter_game_rep)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_5flogic_5fmsg_2eproto();
  friend void protobuf_AssignDesc_client_5flogic_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_client_5flogic_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static msg_enter_game_rep* default_instance_;
};
// -------------------------------------------------------------------

class msg_player_data_rep : public ::google::protobuf::Message {
 public:
  msg_player_data_rep();
  virtual ~msg_player_data_rep();

  msg_player_data_rep(const msg_player_data_rep& from);

  inline msg_player_data_rep& operator=(const msg_player_data_rep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_player_data_rep& default_instance();

  void Swap(msg_player_data_rep* other);

  // implements Message ----------------------------------------------

  msg_player_data_rep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_player_data_rep& from);
  void MergeFrom(const msg_player_data_rep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .net.base_info base_data = 1;
  inline bool has_base_data() const;
  inline void clear_base_data();
  static const int kBaseDataFieldNumber = 1;
  inline const ::net::base_info& base_data() const;
  inline ::net::base_info* mutable_base_data();
  inline ::net::base_info* release_base_data();
  inline void set_allocated_base_data(::net::base_info* base_data);

  // @@protoc_insertion_point(class_scope:net.msg_player_data_rep)
 private:
  inline void set_has_base_data();
  inline void clear_has_base_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::net::base_info* base_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_5flogic_5fmsg_2eproto();
  friend void protobuf_AssignDesc_client_5flogic_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_client_5flogic_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static msg_player_data_rep* default_instance_;
};
// ===================================================================


// ===================================================================

// msg_heart_test

// optional uint32 svr_time = 1;
inline bool msg_heart_test::has_svr_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg_heart_test::set_has_svr_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg_heart_test::clear_has_svr_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg_heart_test::clear_svr_time() {
  svr_time_ = 0u;
  clear_has_svr_time();
}
inline ::google::protobuf::uint32 msg_heart_test::svr_time() const {
  return svr_time_;
}
inline void msg_heart_test::set_svr_time(::google::protobuf::uint32 value) {
  set_has_svr_time();
  svr_time_ = value;
}

// -------------------------------------------------------------------

// msg_login_req

// optional uint32 uid = 1;
inline bool msg_login_req::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg_login_req::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg_login_req::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg_login_req::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 msg_login_req::uid() const {
  return uid_;
}
inline void msg_login_req::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// optional bytes key = 2;
inline bool msg_login_req::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void msg_login_req::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void msg_login_req::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void msg_login_req::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& msg_login_req::key() const {
  return *key_;
}
inline void msg_login_req::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void msg_login_req::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void msg_login_req::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg_login_req::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* msg_login_req::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void msg_login_req::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes deviceid = 3;
inline bool msg_login_req::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void msg_login_req::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void msg_login_req::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void msg_login_req::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& msg_login_req::deviceid() const {
  return *deviceid_;
}
inline void msg_login_req::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void msg_login_req::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void msg_login_req::set_deviceid(const void* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg_login_req::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* msg_login_req::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void msg_login_req::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes versionid = 4;
inline bool msg_login_req::has_versionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void msg_login_req::set_has_versionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void msg_login_req::clear_has_versionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void msg_login_req::clear_versionid() {
  if (versionid_ != &::google::protobuf::internal::kEmptyString) {
    versionid_->clear();
  }
  clear_has_versionid();
}
inline const ::std::string& msg_login_req::versionid() const {
  return *versionid_;
}
inline void msg_login_req::set_versionid(const ::std::string& value) {
  set_has_versionid();
  if (versionid_ == &::google::protobuf::internal::kEmptyString) {
    versionid_ = new ::std::string;
  }
  versionid_->assign(value);
}
inline void msg_login_req::set_versionid(const char* value) {
  set_has_versionid();
  if (versionid_ == &::google::protobuf::internal::kEmptyString) {
    versionid_ = new ::std::string;
  }
  versionid_->assign(value);
}
inline void msg_login_req::set_versionid(const void* value, size_t size) {
  set_has_versionid();
  if (versionid_ == &::google::protobuf::internal::kEmptyString) {
    versionid_ = new ::std::string;
  }
  versionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg_login_req::mutable_versionid() {
  set_has_versionid();
  if (versionid_ == &::google::protobuf::internal::kEmptyString) {
    versionid_ = new ::std::string;
  }
  return versionid_;
}
inline ::std::string* msg_login_req::release_versionid() {
  clear_has_versionid();
  if (versionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = versionid_;
    versionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void msg_login_req::set_allocated_versionid(::std::string* versionid) {
  if (versionid_ != &::google::protobuf::internal::kEmptyString) {
    delete versionid_;
  }
  if (versionid) {
    set_has_versionid();
    versionid_ = versionid;
  } else {
    clear_has_versionid();
    versionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 check_time = 5;
inline bool msg_login_req::has_check_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void msg_login_req::set_has_check_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void msg_login_req::clear_has_check_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void msg_login_req::clear_check_time() {
  check_time_ = 0u;
  clear_has_check_time();
}
inline ::google::protobuf::uint32 msg_login_req::check_time() const {
  return check_time_;
}
inline void msg_login_req::set_check_time(::google::protobuf::uint32 value) {
  set_has_check_time();
  check_time_ = value;
}

// -------------------------------------------------------------------

// msg_login_rep

// optional uint32 result = 1;
inline bool msg_login_rep::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg_login_rep::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg_login_rep::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg_login_rep::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 msg_login_rep::result() const {
  return result_;
}
inline void msg_login_rep::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// optional uint32 server_time = 2;
inline bool msg_login_rep::has_server_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void msg_login_rep::set_has_server_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void msg_login_rep::clear_has_server_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void msg_login_rep::clear_server_time() {
  server_time_ = 0u;
  clear_has_server_time();
}
inline ::google::protobuf::uint32 msg_login_rep::server_time() const {
  return server_time_;
}
inline void msg_login_rep::set_server_time(::google::protobuf::uint32 value) {
  set_has_server_time();
  server_time_ = value;
}

// -------------------------------------------------------------------

// msg_loginout_rep

// optional uint32 reason = 1;
inline bool msg_loginout_rep::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg_loginout_rep::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg_loginout_rep::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg_loginout_rep::clear_reason() {
  reason_ = 0u;
  clear_has_reason();
}
inline ::google::protobuf::uint32 msg_loginout_rep::reason() const {
  return reason_;
}
inline void msg_loginout_rep::set_reason(::google::protobuf::uint32 value) {
  set_has_reason();
  reason_ = value;
}

// optional bytes deviceid = 2;
inline bool msg_loginout_rep::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void msg_loginout_rep::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void msg_loginout_rep::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void msg_loginout_rep::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& msg_loginout_rep::deviceid() const {
  return *deviceid_;
}
inline void msg_loginout_rep::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void msg_loginout_rep::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void msg_loginout_rep::set_deviceid(const void* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg_loginout_rep::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* msg_loginout_rep::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void msg_loginout_rep::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// msg_version_info_rep

// optional bytes version = 1;
inline bool msg_version_info_rep::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg_version_info_rep::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg_version_info_rep::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg_version_info_rep::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& msg_version_info_rep::version() const {
  return *version_;
}
inline void msg_version_info_rep::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void msg_version_info_rep::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void msg_version_info_rep::set_version(const void* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg_version_info_rep::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* msg_version_info_rep::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void msg_version_info_rep::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// msg_enter_game_rep

// optional uint32 result = 1;
inline bool msg_enter_game_rep::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg_enter_game_rep::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg_enter_game_rep::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg_enter_game_rep::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 msg_enter_game_rep::result() const {
  return result_;
}
inline void msg_enter_game_rep::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// msg_player_data_rep

// optional .net.base_info base_data = 1;
inline bool msg_player_data_rep::has_base_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void msg_player_data_rep::set_has_base_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void msg_player_data_rep::clear_has_base_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void msg_player_data_rep::clear_base_data() {
  if (base_data_ != NULL) base_data_->::net::base_info::Clear();
  clear_has_base_data();
}
inline const ::net::base_info& msg_player_data_rep::base_data() const {
  return base_data_ != NULL ? *base_data_ : *default_instance_->base_data_;
}
inline ::net::base_info* msg_player_data_rep::mutable_base_data() {
  set_has_base_data();
  if (base_data_ == NULL) base_data_ = new ::net::base_info;
  return base_data_;
}
inline ::net::base_info* msg_player_data_rep::release_base_data() {
  clear_has_base_data();
  ::net::base_info* temp = base_data_;
  base_data_ = NULL;
  return temp;
}
inline void msg_player_data_rep::set_allocated_base_data(::net::base_info* base_data) {
  delete base_data_;
  base_data_ = base_data;
  if (base_data) {
    set_has_base_data();
  } else {
    clear_has_base_data();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace net

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_5flogic_5fmsg_2eproto__INCLUDED
